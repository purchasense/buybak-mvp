"""
/////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2025 Sameer Kulkarni.
//  BuyBak - Proprietary and Confidencial. All rights reserved.
//
//  author - Sameer Kulkarni, sameer@buybak.io, sameerk1973@gmail.com
//  Input File   - MyWorkflow.sm
//
/////////////////////////////////////////////////////////////////////
                       
This file is AUTO-GENERATED. PLEASE DO NOT EDIT THIS FILE
                       
"""

from buybakworkflow.MyWorkflowContext import *
from buybakworkflow.MyWorkflowEvents import *
from llama_index.llms.openai import OpenAI
from buybakworkflow.events import *
from pathlib import Path
from typing import List
from llama_index.core.workflow import Event
from buybakworkflow.schemas import *
from llama_index.core.workflow import ( StartEvent, StopEvent, Workflow, step, Event, Context)
import click
import asyncio
import json
import random
import shutil
import string
import uuid
import json
import asyncio
import inspect
global_list = []


class MyWorkflow(Workflow):
    sameer_here:   str = Field(..., description="placeholder")
    fsmc:   MyWorkflowContext = Field(..., description="Action Functions")

    def __init__(self, fsmc: MyWorkflowContext, *args, **kwargs):
        print("Inside __init__")
        super().__init__(*args, **kwargs)
        # initialize the Future
        self.fsmc = fsmc
        # user_input for FSMC asking qustions (AI or not to AI)
        self.user_input_future = asyncio.Future()
        # live market data injected into the state machine, non-blocking polling, via ProConQueue 
        self.live_market_future = asyncio.Future()
        
    async def run(self, *args, **kwargs):
            self.loop = asyncio.get_running_loop() # store the event loop
            return await super().run(*args, **kwargs)
 
    async def reset_user_input_future(self):
        self.user_input_future = self.loop.create_future()
 
    async def reset_live_market_future(self):
        self.live_market_future = self.loop.create_future()
 
    @step
    async def generic_q_state(self,ctx: Context, ev:  StartEvent) ->  FirstEvent:
        print("Inside generic_q_state")
        await self.fsmc.what_is_action(ctx, ev, 'What are the wines I can query, in HTML Table')
        await self.fsmc.suneels_action_function(ctx, ev, 'I am Suneel!')
        
        return FirstEvent(first_output="First step complete.")


    @step
    async def start_timer_state(self,ctx: Context, ev:  FirstEvent) ->  WfTimerEvent:
        print("Inside start_timer_state")
        await self.fsmc.two_action_1(ctx, ev, 'call action_1')
        
        return WfTimerEvent(timer="5",name="timer_5")


    @step
    async def wf_timer_state(self,ctx: Context, ev:  WfTimerEvent) ->  TimerFiredEvent:
        print("Inside wf_timer_state")
        await self.fsmc.generate_stream_event(ctx, ev, 'agent', 'WfTimerEvent', 'step_timer', 'outline', 'armed, Waitime for Timer')
        await self.fsmc.armTimer(ctx, ev, '1', 'state::step_timer')
        
        return TimerFiredEvent(timer="5",name="timer_fired")


    @step
    async def end_timer_state(self,ctx: Context, ev:  TimerFiredEvent) ->  GetUserEvent:
        print("Inside end_timer_state")
        await self.fsmc.generate_stream_event(ctx, ev, 'input', 'SecondEvent', 'step_three', 'outline', 'Timer Popped!')
        await self.fsmc.two_action_1(ctx, ev, 'call action_2')
        
        return GetUserEvent(msg="Hello World")


    @step
    async def user_input_state(self,ctx: Context, ev:  GetUserEvent) ->  ForecastEvent |  FrenchWinesEvent |  LiveMarketEvent:
        print("Inside user_input_state")
        await self.fsmc.generate_stream_event(ctx, ev, 'agent', 'GetUserEvent', 'step_four', 'outline', 'U can ask AI (forecast, describe, or Live-Market). Query?')
        ret_val, user_response = await self.fsmc.conditional_fore_wine_live(ctx, ev, self.user_input_future, ev.msg)
        await self.reset_user_input_future()
        
        if ret_val == 0:
            return ForecastEvent(query=user_response)
        elif ret_val == 1:
            return FrenchWinesEvent(query=user_response)
        else:
            return LiveMarketEvent(md=user_response)


    @step
    async def forecast_state(self,ctx: Context, ev:  ForecastEvent) ->  GetUserEvent |  StopEvent:
        print("Inside forecast_state")
        ret_val, user_response = await self.fsmc.conditional_forecast_ema(ctx, ev, self.user_input_future, ev.query)
        await self.reset_user_input_future()
        
        if ret_val == True:
            return GetUserEvent(msg=user_response)
        else:
            return StopEvent(result=user_response)


    @step
    async def lookup_french_wines_state(self,ctx: Context, ev:  FrenchWinesEvent) ->  GetUserEvent:
        print("Inside lookup_french_wines_state")
        await self.fsmc.buybak_french_wines_action(ctx, ev, ev.query)
        
        return GetUserEvent(msg="Sameer")


    @step
    async def market_data_state(self,ctx: Context, ev:  LiveMarketEvent) ->  CompareMarketEvent |  StopEvent:
        print("Inside market_data_state")
        ret_val, user_response = await self.fsmc.conditional_market_action(ctx, ev, self.live_market_future, ev.md)
        await self.reset_live_market_future()
        
        if ret_val == True:
            return CompareMarketEvent(md=user_response)
        else:
            return StopEvent(result=user_response)


    @step
    async def user_decision_state(self,ctx: Context, ev:  CompareMarketEvent) ->  BuyOrSellEvent |  LiveMarketEvent:
        print("Inside user_decision_state")
        ret_val, user_response = await self.fsmc.conditional_compare_market_action(ctx, ev, self.live_market_future, ev.md)
        await self.reset_live_market_future()
        
        if ret_val == True:
            return BuyOrSellEvent(md=user_response)
        else:
            return LiveMarketEvent(md=user_response)


    @step
    async def buy_sell_state(self,ctx: Context, ev:  BuyOrSellEvent) ->  ShoppingCartEvent |  LiveMarketEvent |  StopEvent:
        print("Inside buy_sell_state")
        await self.fsmc.generate_stream_event(ctx, ev, 'agent', 'BuyOrSellEvent', 'buy_sell_state', 'outline', 'Choose Buy, Not, or Exit?')
        ret_val, user_response = await self.fsmc.conditional_buy_or_sell_action(ctx, ev, self.user_input_future, ev.md)
        await self.reset_user_input_future()
        
        if ret_val == 0:
            return ShoppingCartEvent(item=user_response)
        elif ret_val == 1:
            return LiveMarketEvent(md=user_response)
        else:
            return StopEvent(result=user_response)


    @step
    async def shopping_cart_state(self,ctx: Context, ev:  ShoppingCartEvent) ->  LiveMarketEvent:
        print("Inside shopping_cart_state")
        await self.fsmc.shopping_cart_action(ctx, ev, ev.item)
        
        return LiveMarketEvent(md="ShoppingCartEnd")



async def run_workflow(first_input: str):
    fsmc = MyWorkflowContext()
    w = MyWorkflow(fsmc=fsmc, timeout=30, verbose=True)
    result = await w.run(first_input=first_input)
    print("Final result", result)

@click.command()
@click.option(
    "--user-query",
    "-q",
    required=False,
    help="The user query",
    default="MyWorkflow",
)
def main(user_query: str):
    from llama_index.utils.workflow import draw_all_possible_flows
    draw_all_possible_flows( MyWorkflow, filename="graphs/GraphMyWorkflow.html")

    asyncio.run(run_workflow(user_query))

if __name__ == "__main__":
    asyncio.run(main())

"""
/////////////////////////////////////////////////////////////////////
                       
This file is AUTO-GENERATED. PLEASE DO NOT EDIT THIS FILE
                       
/////////////////////////////////////////////////////////////////////
"""
