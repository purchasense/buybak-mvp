import os, json
from typing import List
import array
import sys
from llama_index.core.workflow import (Workflow)
import pandas as pd
from typing import Optional
from typing import ClassVar
from typing import List
from pydantic import BaseModel, Field
import json

class FSMCWorkflow(Workflow):

    fsmc_file = ""
    events_array: List = []

    def __init__(self, fsmc_file, *args, **kwargs):

        self.fsmc_file = fsmc_file
        with open(self.fsmc_file, 'r') as file:
            self.state_machine = json.load(file)
        # TODO print(self.state_machine)

    def generate_prologue(self):
        print("\"\"\"")
        print("/////////////////////////////////////////////////////////////////////")
        print("//")
        print("//  Copyright (c) 2025 Sameer Kulkarni.")
        print("//  BuyBak - Proprietary and Confidencial. All rights reserved.")
        print("//")
        print("//  author - Sameer Kulkarni, sameer@buybak.io, sameerk1973@gmail.com")
        print(f"//  Input File   - {self.state_machine['fsmc']['name']}.sm")
        print("//")
        print("/////////////////////////////////////////////////////////////////////")
        print("                       ")
        print("This file is AUTO-GENERATED. PLEASE DO NOT EDIT THIS FILE")
        print("                       ")
        print("\"\"\"")

        self.events_array.append("\"\"\"")
        self.events_array.append("/////////////////////////////////////////////////////////////////////")
        self.events_array.append("//")
        self.events_array.append("//  Copyright (c) 2025 Sameer Kulkarni.")
        self.events_array.append("//  BuyBak - Proprietary and Confidencial. All rights reserved.")
        self.events_array.append("//")
        self.events_array.append("//  author - Sameer Kulkarni, sameer@buybak.io, sameerk1973@gmail.com")
        self.events_array.append(f"//  File   - {self.state_machine['fsmc']['name']}Events.py")
        self.events_array.append("//")
        self.events_array.append("/////////////////////////////////////////////////////////////////////")
        self.events_array.append("                       ")
        self.events_array.append("This file is AUTO-GENERATED. PLEASE DO NOT EDIT THIS FILE")
        self.events_array.append("                       ")
        self.events_array.append("\"\"\"")

    def generate_imports(self):
        print("")
        print(f'from buybakworkflow.{self.state_machine["fsmc"]["name"]}Context import *')
        print(f'from buybakworkflow.{self.state_machine["fsmc"]["name"]}Events import *')
        for i in self.state_machine['fsmc']['headers']: 
            print(i)
        print("")

        self.events_array.append("")
        self.events_array.append(f'from buybakworkflow.{self.state_machine["fsmc"]["name"]}Context import *')
        for i in self.state_machine['fsmc']['headers']: 
            self.events_array.append(i)
        self.events_array.append("")

    def generate_dictionary(self):
        self.events_array.append("")
        for base_model in self.state_machine['fsmc']['dictionary']: 
            self.events_array.append(f'class {base_model["class"]}(BaseModel):')
            for attrs in  base_model['attributes']:
                keys = list(attrs.keys())
                self.events_array.append(f'    {keys[0]}:   {attrs[keys[0]]} = Field({attrs["field"]})')
            self.events_array.append("")
        self.events_array.append("")

    def generate_stimulus_events(self):
        self.events_array.append("")
        for event_model in self.state_machine['fsmc']['stimuli']: 
            self.events_array.append(f'class {event_model["method"]}({event_model["args"]}):')
            for attrs in  event_model['body']:
                keys = list(attrs.keys())
                self.events_array.append(f'    {keys[0]}:   {attrs[keys[0]]}')
            self.events_array.append("")
        self.events_array.append("")

    def generate_workflow_member_vars(self):
        print("")
        print(f'class {self.state_machine["fsmc"]["name"]}(Workflow):')
        for attrs in  self.state_machine['fsmc']['membervars']:
            print(f'    {attrs["name"]}:   {attrs["type"]} = Field({attrs["field"]})')
        print(f'    fsmc:   {self.state_machine["fsmc"]["name"]}Context = Field(..., description="Action Functions")')
        print("")

    def generate_additional_args(self, args: str, steps: []) -> tuple[str, str]:
        evs = ""
        count = len(steps["stimuli"])
        index = 0
        for stimuli in steps["stimuli"]:
            evs = evs + f' {stimuli["stimulus"]}'
            index = index + 1
            if index < count:
                evs = evs + " | "
        args = args + ", ev: " + evs    

        emits = ""
        index = 0
        count = len(steps["emits"])
        for events in steps["emits"]:
            emits = emits + f' {events["event"]}'
            index = index + 1
            if index < count:
                emits = emits + " | "
        return args, emits
            
    def generate_actions_and_emits(self, steps: []):
        for stimuli in steps["stimuli"]:
            for acts in stimuli["actions"]:
                quoted_list = []
                for item in acts["args"]:
                    if "ev" in item:
                        quoted_list.append(item)
                    else:
                        quoted_list.append("'" + item + "'")
                args = ", ".join(quoted_list)
                if len(steps["emits"]) == 2 and "conditional" in acts["action"]:
                    emit_if = steps["emits"][0]
                    emit_else = steps["emits"][-1]
                    fut_var = "live_market_future" if "market" in acts["action"] else "user_input_future"
                    print(f'        ret_val, user_response = await self.fsmc.{acts["action"]}(ctx, ev, self.{fut_var}, {args})')
                    print(f'        await self.reset_{fut_var}()')
                    print(f'        ')
                    print(f'        if ret_val == True:')
                    print(f'            return {emit_if["event"]}({",".join(emit_if["args"])})')
                    print(f'        else:')
                    print(f'            return {emit_else["event"]}({",".join(emit_else["args"])})')
                elif len(steps["emits"]) == 3 and "conditional" in acts["action"]:
                    emit_0 = steps["emits"][0]
                    emit_1 = steps["emits"][1]
                    emit_2 = steps["emits"][-1]
                    fut_var = "user_input_future" 
                    print(f'        ret_val, user_response = await self.fsmc.{acts["action"]}(ctx, ev, self.{fut_var}, {args})')
                    print(f'        await self.reset_{fut_var}()')
                    print(f'        ')
                    print(f'        if ret_val == 0:')
                    print(f'            return {emit_0["event"]}({",".join(emit_0["args"])})')
                    print(f'        elif ret_val == 1:')
                    print(f'            return {emit_1["event"]}({",".join(emit_1["args"])})')
                    print(f'        else:')
                    print(f'            return {emit_2["event"]}({",".join(emit_2["args"])})')
                else:
                    print(f'        await self.fsmc.{acts["action"]}(ctx, ev, {args})')

            if len(steps["emits"]) == 1:
                emiting = steps["emits"][0]
                print(f'        ')
                print(f'        return {emiting["event"]}({",".join(emiting["args"])})')
            print("")

    def generate_workflow_steps(self):
        for steps in self.state_machine["fsmc"]["steps"]:
            delimiter = ","
            args = delimiter.join(steps["args"])
            if steps["state"] == "__init__":
                
                print(f'    def __init__(self, region: str, fsmc: {self.state_machine["fsmc"]["name"]}Context, *args, **kwargs):')
                print(f'        print(\"Inside {steps["state"]}\")')
                print(f'        super().__init__(*args, **kwargs)')
                print(f'        # initialize the Future')
                print(f'        self.region = region')
                print(f'        self.fsmc = fsmc')
                print(f'        # user_input for FSMC asking qustions (AI or not to AI)')
                print(f'        self.user_input_future = asyncio.Future()')
                print(f'        # live market data injected into the state machine, non-blocking polling, via ProConQueue ')
                print(f'        self.live_market_future = asyncio.Future()')
                print(f'        ')
                print(f'    async def run(self, *args, **kwargs):')
                print(f'            self.loop = asyncio.get_running_loop() # store the event loop')
                print(f'            return await super().run(*args, **kwargs)')
                print(f' ')
                print(f'    async def reset_user_input_future(self):')
                print(f'        self.user_input_future = self.loop.create_future()')
                print(f' ')
                print(f'    async def reset_live_market_future(self):')
                print(f'        self.live_market_future = self.loop.create_future()')
                print(f' ')

            else:
                # args = args + f', fsmc: {self.state_machine["fsmc"]["name"]}Context '
                [args, emits] = self.generate_additional_args(args, steps)

                print("    @step")
                print(f'    async def {steps["state"]}({args}) -> {emits}:')
                print(f'        print(\"Inside {steps["state"]}\")')
                self.generate_actions_and_emits(steps)
                print("")
        print("")

    def generate_main(self):
        print(f'async def run_workflow(first_input: str):')
        print(f'    fsmc = {self.state_machine["fsmc"]["name"]}Context()')
        print(f'    w = {self.state_machine["fsmc"]["name"]}(fsmc=fsmc, timeout=30, verbose=True)')
        print(f'    result = await w.run(first_input=first_input)')
        print(f'    print("Final result", result)')
        print(f'')
        print(f'@click.command()')
        print(f'@click.option(')
        print(f'    "--user-query",')
        print(f'    "-q",')
        print(f'    required=False,')
        print(f'    help="The user query",')
        print(f'    default="{self.state_machine["fsmc"]["name"]}",')
        print(f')')
        print(f'def main(user_query: str):')
        print(f'    from llama_index.utils.workflow import draw_all_possible_flows')
        print(f'    draw_all_possible_flows( {self.state_machine["fsmc"]["name"]}, filename=\"graphs/Graph{self.state_machine["fsmc"]["name"]}.html\")')
        print(f'')
        print(f'    asyncio.run(run_workflow(user_query))')
        print(f'')
        print(f'if __name__ == "__main__":')
        print(f'    asyncio.run(main())')
        print(f'')
        print("\"\"\"")
        print("/////////////////////////////////////////////////////////////////////")
        print("                       ")
        print("This file is AUTO-GENERATED. PLEASE DO NOT EDIT THIS FILE")
        print("                       ")
        print("/////////////////////////////////////////////////////////////////////")
        print("\"\"\"")

    def generate_events_file(self):
        # Let's write the events file now
        eventsFile = f'buybakworkflow/{self.state_machine["fsmc"]["name"]}Events.py'
        with open(eventsFile, "w") as file:
            for line in self.events_array:
                file.write(line + "\n")
            file.close()

async def main():
    if len(sys.argv) >= 2:
        fsmc = FSMCWorkflow(fsmc_file=sys.argv[1], timeout=30, verbose=True)
        fsmc.generate_prologue()
        fsmc.generate_imports()
        fsmc.generate_dictionary()
        fsmc.generate_stimulus_events()
        fsmc.generate_workflow_member_vars()
        fsmc.generate_workflow_steps()
        fsmc.generate_main()
        fsmc.generate_events_file()

    else:
        print("Please provide <FSMC.sm>")

if __name__ == "__main__":
    import asyncio
    asyncio.run(main())


